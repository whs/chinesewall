[6139, 6148]
from typing import List, Dict


class Node:
    '''Simple node (No duplicate edges between nodes)'''

    def __init__(self, id: int):
        self.id = id
        self.out_edges = []
        self.in_edges = []

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return False
        else:
            return self.id == __value.id

    def __hash__(self) -> int:
        return self.id


class Graph:
    '''Simple directed graph (No duplicate edges between nodes, no duplicate nodes)'''

    def __init__(self, nodes: List[Node]):
        uniques = {}
        for node in nodes:
            if node in uniques.keys():
                raise RuntimeError
            else:
                uniques[node] = True
        self.nodes = nodes

    def add_edge(self, src: Node, dest: Node):
        assert src not in dest.in_edges
        assert dest not in src.out_edges
        src.out_edges.append(dest)
        dest.in_edges.append(src)

    def reverse_edges(self):
        reversed = Graph(list(map(lambda x: Node(x.id), self.nodes)))
        for i, node in enumerate(self.nodes):
            reversed.nodes[i].in_edges = node.out_edges
            reversed.nodes[i].out_edges = node.in_edges
        return reversed

    def DFS(self, src: Node) -> List[Node]:
        assert src in self.nodes

        visited = []
        to_visit = []
        to_visit.append(src)

        while len(to_visit) != 0:
            first = to_visit.pop()
            if first in visited:
                continue
            for n in first.out_edges:
                to_visit.append(n)

            visited.append(first)

        return visited

    # EDIT: Add a new method `strongly_connected_components` to the `Graph` class.
    # This method should not take any arguments other than `self`.
    # It should return a dictionary where keys are the graph's `Node` objects and values are integer IDs
    # representing the strongly connected component they belong to.
    # The overall approach is called Kosaraju's algorithm. It has three main steps.

    # --- Step 1: First DFS pass to get node processing order ---
    # We need to visit nodes in a specific order in the second part of the algorithm.
    # To find this order, we'll perform a DFS on the original graph.
    # After the search finishes exploring from a node, we'll add it to a list.

    # EDIT: Create an empty list, let's call it `processing_order`, to store the nodes.
    # EDIT: Create an empty set, let's call it `visited_nodes`, to keep track of nodes visited in this first pass.

    # EDIT: Define a nested helper function, for example `dfs_pass1(node)`.
    # This function will perform the DFS. It should take one argument: the node to start from.
    # Inside `dfs_pass1(node)`:
    # 1. Add the `node` to `visited_nodes`.
    # 2. Loop through each `neighbor` in the `node.out_edges`.
    # 3. If a `neighbor` has not been visited yet (i.e., it's not in `visited_nodes`),
    #    recursively call `dfs_pass1` on that `neighbor`.
    # 4. After the loop finishes (meaning all reachable nodes have been visited),
    #    add the current `node` to the `processing_order` list.

    # EDIT: Now, iterate through all the nodes in `self.nodes`.
    # For each `node`, check if it's in `visited_nodes`.
    # If it's not, call your helper function `dfs_pass1` with that `node`.

    # --- Step 2: Create the reversed graph ---
    # The next step requires a graph with all edge directions flipped.
    # EDIT: Call the `self.reverse_edges()` method and store the result in a variable, e.g., `reversed_graph`.

    # --- Step 3: Second DFS pass to find components ---
    # Now we'll do a second DFS, this time on the `reversed_graph`.
    # We will process nodes in the reverse of the order we found in Step 1.

    # EDIT: Create an empty dictionary, let's call it `scc_result`, to store the final mapping of node to component ID.
    # EDIT: Create a new empty set, let's call it `visited_reversed_nodes`, for this second pass.
    # EDIT: Initialize a variable `component_id` to 0. This will be the ID for the first component we find.

    # EDIT: Because `reversed_graph` contains new node objects, we need a way to link them
    # back to the original nodes. Let's create two dictionaries for easy lookup.
    # 1. `original_nodes_by_id`: maps `node.id` to `node` for every node in `self.nodes`.
    # 2. `reversed_nodes_by_id`: maps `node.id` to `node` for every node in `reversed_graph.nodes`.

    # EDIT: Define another nested helper function, for example `dfs_pass2(node, current_component_id)`.
    # This function will find all nodes in a single component. It takes the starting node (from the reversed graph)
    # and the current component ID as arguments.
    # Inside `dfs_pass2(node, current_component_id)`:
    # 1. Add the `node` to `visited_reversed_nodes`.
    # 2. Find the corresponding original node using the `original_nodes_by_id` map and the `node.id`.
    # 3. Add an entry to `scc_result`: the key is the original node, and the value is `current_component_id`.
    # 4. Loop through each `neighbor` in the `node.out_edges` of the *reversed graph*.
    # 5. If a `neighbor` has not been visited yet (i.e., it's not in `visited_reversed_nodes`),
    #    recursively call `dfs_pass2` on that `neighbor`, passing the same `current_component_id`.

    # EDIT: Now, iterate through the `processing_order` list from Step 1, but in REVERSE order.
    # For each `node_from_order` in the reversed `processing_order`:
    # 1. Find the corresponding node in the reversed graph using its ID. Use the `reversed_nodes_by_id` map you created.
    #    Let's call this `reversed_node`.
    # 2. Check if this `reversed_node` is in `visited_reversed_nodes`.
    # 3. If it has NOT been visited:
    #    a. It means we've found a new strongly connected component.
    #    b. Call your helper function `dfs_pass2` with `reversed_node` and the current `component_id`.
    #    c. After the call returns, increment the `component_id` for the next component.

    # EDIT: Finally, return the `scc_result` dictionary.

===============
```py
from typing import List, Dict


class Node:
    '''Simple node (No duplicate edges between nodes)'''

    def __init__(self, id: int):
        self.id = id
        self.out_edges = []
        self.in_edges = []

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return False
        else:
            return self.id == __value.id

    def __hash__(self) -> int:
        return self.id


class Graph:
    '''Simple directed graph (No duplicate edges between nodes, no duplicate nodes)'''

    def __init__(self, nodes: List[Node]):
        uniques = {}
        for node in nodes:
            if node in uniques.keys():
                raise RuntimeError
            else:
                uniques[node] = True
        self.nodes = nodes

    def add_edge(self, src: Node, dest: Node):
        assert src not in dest.in_edges
        assert dest not in src.out_edges
        src.out_edges.append(dest)
        dest.in_edges.append(src)

    def reverse_edges(self):
        reversed = Graph(list(map(lambda x: Node(x.id), self.nodes)))
        for i, node in enumerate(self.nodes):
            reversed.nodes[i].in_edges = node.out_edges
            reversed.nodes[i].out_edges = node.in_edges
        return reversed

    def DFS(self, src: Node) -> List[Node]:
        assert src in self.nodes

        visited = []
        to_visit = []
        to_visit.append(src)

        while len(to_visit) != 0:
            first = to_visit.pop()
            if first in visited:
                continue
            for n in first.out_edges:
                to_visit.append(n)

            visited.append(first)

        return visited

    # EDIT: Add a new method `strongly_connected_components` to the `Graph` class.
    # This method should not take any arguments other than `self`.
    # It should return a dictionary where keys are the graph's `Node` objects and values are integer IDs
    # representing the strongly connected component they belong to.
    # The overall approach is called Kosaraju's algorithm. It has three main steps.

    # --- Step 1: First DFS pass to get node processing order ---
    # We need to visit nodes in a specific order in the second part of the algorithm.
    # To find this order, we'll perform a DFS on the original graph.
    # After the search finishes exploring from a node, we'll add it to a list.

    # EDIT: Create an empty list, let's call it `processing_order`, to store the nodes.
    # EDIT: Create an empty set, let's call it `visited_nodes`, to keep track of nodes visited in this first pass.

    # EDIT: Define a nested helper function, for example `dfs_pass1(node)`.
    # This function will perform the DFS. It should take one argument: the node to start from.
    # Inside `dfs_pass1(node)`:
    # 1. Add the `node` to `visited_nodes`.
    # 2. Loop through each `neighbor` in the `node.out_edges`.
    # 3. If a `neighbor` has not been visited yet (i.e., it's not in `visited_nodes`),
    #    recursively call `dfs_pass1` on that `neighbor`.
    # 4. After the loop finishes (meaning all reachable nodes have been visited),
    #    add the current `node` to the `processing_order` list.

    # EDIT: Now, iterate through all the nodes in `self.nodes`.
    # For each `node`, check if it's in `visited_nodes`.
    # If it's not, call your helper function `dfs_pass1` with that `node`.

    # --- Step 2: Create the reversed graph ---
    # The next step requires a graph with all edge directions flipped.
    # EDIT: Call the `self.reverse_edges()` method and store the result in a variable, e.g., `reversed_graph`.

    # --- Step 3: Second DFS pass to find components ---
    # Now we'll do a second DFS, this time on the `reversed_graph`.
    # We will process nodes in the reverse of the order we found in Step 1.

    # EDIT: Create an empty dictionary, let's call it `scc_result`, to store the final mapping of node to component ID.
    # EDIT: Create a new empty set, let's call it `visited_reversed_nodes`, for this second pass.
    # EDIT: Initialize a variable `component_id` to 0. This will be the ID for the first component we find.

    # EDIT: Because `reversed_graph` contains new node objects, we need a way to link them
    # back to the original nodes. Let's create two dictionaries for easy lookup.
    # 1. `original_nodes_by_id`: maps `node.id` to `node` for every node in `self.nodes`.
    # 2. `reversed_nodes_by_id`: maps `node.id` to `node` for every node in `reversed_graph.nodes`.

    # EDIT: Define another nested helper function, for example `dfs_pass2(node, current_component_id)`.
    # This function will find all nodes in a single component. It takes the starting node (from the reversed graph)
    # and the current component ID as arguments.
    # Inside `dfs_pass2(node, current_component_id)`:
    # 1. Add the `node` to `visited_reversed_nodes`.
    # 2. Find the corresponding original node using the `original_nodes_by_id` map and the `node.id`.
    # 3. Add an entry to `scc_result`: the key is the original node, and the value is `current_component_id`.
    # 4. Loop through each `neighbor` in the `node.out_edges` of the *reversed graph*.
    # 5. If a `neighbor` has not been visited yet (i.e., it's not in `visited_reversed_nodes`),
    #    recursively call `dfs_pass2` on that `neighbor`, passing the same `current_component_id`.

    # EDIT: Now, iterate through the `processing_order` list from Step 1, but in REVERSE order.
    # For each `node_from_order` in the reversed `processing_order`:
    # 1. Find the corresponding node in the reversed graph using its ID. Use the `reversed_nodes_by_id` map you created.
    #    Let's call this `reversed_node`.
    # 2. Check if this `reversed_node` is in `visited_reversed_nodes`.
    # 3. If it has NOT been visited:
    #    a. It means we've found a new strongly connected component.
    #    b. Call your helper function `dfs_pass2` with `reversed_node` and the current `component_id`.
    #    c. After the call returns, increment the `component_id` for the next component.

    # EDIT: Finally, return the `scc_result` dictionary.
```
