[2722, 2731]
# EDIT: Import `Dict` from the `typing` module.
from typing import List


class Node:
    '''Simple node (No duplicate edges between nodes)'''

    def __init__(self, id: int):
        self.id = id
        self.out_edges = []
        self.in_edges = []

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return False
        else:
            return self.id == __value.id

    def __hash__(self) -> int:
        return self.id


class Graph:
    '''Simple directed graph (No duplicate edges between nodes, no duplicate nodes)'''

    def __init__(self, nodes: List[Node]):
        uniques = {}
        for node in nodes:
            if node in uniques.keys():
                raise RuntimeError
            else:
                uniques[node] = True
        self.nodes = nodes

    def add_edge(self, src: Node, dest: Node):
        assert src not in dest.in_edges
        assert dest not in src.out_edges
        src.out_edges.append(dest)
        dest.in_edges.append(src)

    def reverse_edges(self):
        reversed = Graph(list(map(lambda x: Node(x.id), self.nodes)))
        for i, node in enumerate(self.nodes):
            reversed.nodes[i].in_edges = node.out_edges
            reversed.nodes[i].out_edges = node.in_edges
        return reversed

    def DFS(self, src: Node) -> List[Node]:
        assert src in self.nodes

        visited = []
        to_visit = []
        to_visit.append(src)

        while len(to_visit) != 0:
            first = to_visit.pop()
            if first in visited:
                continue
            for n in first.out_edges:
                to_visit.append(n)

            visited.append(first)

        return visited

    # EDIT: Define a new method here named `adjacency_list`.
    # EDIT: It should take `self` as its only parameter.
    # EDIT: Add a type hint to indicate that this method returns a dictionary where keys are `Node` objects and values are lists of `Node` objects. The type hint should be `-> Dict[Node, List[Node]]`.
    
        # EDIT: Create a new empty dictionary. This will store the nodes and their neighbors. Let's call it `adj_list`.
        
        # EDIT: Start a loop that goes through each `node` in the graph's list of nodes, which is `self.nodes`.
        
            # EDIT: Inside the loop, for the current `node`, add an entry to the `adj_list` dictionary.
            # EDIT: The key should be the current `node` object.
            # EDIT: The value should be the list of nodes that the current `node` has an edge pointing to. This list is stored in the `out_edges` attribute of the `node`.
            
        # EDIT: After the loop finishes, return the `adj_list` dictionary.

===============
```py
# EDIT: Import `Dict` from the `typing` module.
from typing import List


class Node:
    '''Simple node (No duplicate edges between nodes)'''

    def __init__(self, id: int):
        self.id = id
        self.out_edges = []
        self.in_edges = []

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return False
        else:
            return self.id == __value.id

    def __hash__(self) -> int:
        return self.id


class Graph:
    '''Simple directed graph (No duplicate edges between nodes, no duplicate nodes)'''

    def __init__(self, nodes: List[Node]):
        uniques = {}
        for node in nodes:
            if node in uniques.keys():
                raise RuntimeError
            else:
                uniques[node] = True
        self.nodes = nodes

    def add_edge(self, src: Node, dest: Node):
        assert src not in dest.in_edges
        assert dest not in src.out_edges
        src.out_edges.append(dest)
        dest.in_edges.append(src)

    def reverse_edges(self):
        reversed = Graph(list(map(lambda x: Node(x.id), self.nodes)))
        for i, node in enumerate(self.nodes):
            reversed.nodes[i].in_edges = node.out_edges
            reversed.nodes[i].out_edges = node.in_edges
        return reversed

    def DFS(self, src: Node) -> List[Node]:
        assert src in self.nodes

        visited = []
        to_visit = []
        to_visit.append(src)

        while len(to_visit) != 0:
            first = to_visit.pop()
            if first in visited:
                continue
            for n in first.out_edges:
                to_visit.append(n)

            visited.append(first)

        return visited

    # EDIT: Define a new method here named `adjacency_list`.
    # EDIT: It should take `self` as its only parameter.
    # EDIT: Add a type hint to indicate that this method returns a dictionary where keys are `Node` objects and values are lists of `Node` objects. The type hint should be `-> Dict[Node, List[Node]]`.
    
        # EDIT: Create a new empty dictionary. This will store the nodes and their neighbors. Let's call it `adj_list`.
        
        # EDIT: Start a loop that goes through each `node` in the graph's list of nodes, which is `self.nodes`.
        
            # EDIT: Inside the loop, for the current `node`, add an entry to the `adj_list` dictionary.
            # EDIT: The key should be the current `node` object.
            # EDIT: The value should be the list of nodes that the current `node` has an edge pointing to. This list is stored in the `out_edges` attribute of the `node`.
            
        # EDIT: After the loop finishes, return the `adj_list` dictionary.
```
