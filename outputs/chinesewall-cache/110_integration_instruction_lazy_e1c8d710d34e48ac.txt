[3544, 3553]
from typing import Optional
import numpy as np
from autograd import grad

class integrator:
    def __init__(self, lower: float, upper: float, stepsize: float): 
        self.lower = lower
        self.upper = upper
        self.stepsize = stepsize

    def rectangle_left(self, f):
        result = 0
        x = self.lower
        while x < self.upper:
            result += f(x) * self.stepsize
            x += self.stepsize
        return result

    def rectangle_right(self, f):
        result = 0
        x = self.lower + self.stepsize
        while x <= self.upper:
            result += f(x) * self.stepsize
            x += self.stepsize
        return result

    def rectangle_middle(self, f):
        result = 0
        x = self.lower + self.stepsize / 2
        while x < self.upper:
            result += f(x) * self.stepsize
            x += self.stepsize
        return result

    def M_search(self, f, num_points: Optional[int] = 100) -> float:
        second_derivative = grad(grad(f))
        x = np.linspace(self.lower, self.upper, num_points)
        return max(np.abs(second_derivative(x)))

    def middle_error(self, f):
        M = self.M_search(f) 
        return M * (self.upper - self.lower)**3  / (24 * self.stepsize**2 )

    def determine_stepsize_middle(self, f, error: float) -> int:
        M = self.M_search(f)
        return int(np.sqrt((M * (self.upper - self.lower)**3) / (24 * error))) + 1
        
    def trapezoid(self, f):
        result = 0
        x = self.lower
        while x < self.upper:
            result += (f(x) + f(x + self.stepsize)) * self.stepsize / 2
            x += self.stepsize
        return result

    def trapezoid_error(self, f):
        M = self.M_search(f)
        return M * (self.upper - self.lower)**3 / (12  * self.stepsize**2) 

    def determine_stepsize_trapezoid(self, f, error: float) -> int:
        M = self.M_search(f)
        return int(np.sqrt((M * (self.upper - self.lower)**3) / (12 * error))) + 1

    # EDIT: Add a new method here called `simpson`. It should take `self` and a function `f` as arguments.
    # Inside this new method, you will write the code to perform an integration using Simpson's rule.
    # The formula for Simpson's rule is (h/3) * [f(x_0) + 4f(x_1) + 2f(x_2) + ... + 4f(x_{n-1}) + f(x_n)],
    # where h is the stepsize and n is the number of intervals.
    # Follow these steps inside the method:
    # 1. Calculate the number of intervals, `n`, by dividing the integration range (`self.upper` - `self.lower`) by `self.stepsize`. Round this to the nearest integer.
    # 2. Simpson's rule requires an even number of intervals. Add a check to see if `n` is odd. If it is, raise a `ValueError` with an informative message.
    # 3. Initialize a variable, let's call it `total_sum`, to 0. This will hold the weighted sum of function values.
    # 4. Create a `for` loop that iterates with an index `i` from 0 to `n` (inclusive).
    # 5. Inside the loop, first calculate the current x-position for the index `i`.
    # 6. Next, determine the weight for the current point.
    #    - If it's an endpoint (i.e., `i` is 0 or `n`), the weight is 1.
    #    - If `i` is an odd number, the weight is 4.
    #    - If `i` is an even number (and not an endpoint), the weight is 2.
    # 7. Add the function value at the current x-position, multiplied by its weight, to `total_sum`.
    # 8. After the loop finishes, calculate the final integral by multiplying `total_sum` by `self.stepsize / 3`.
    # 9. Return this final integral value.

===============
```py
from typing import Optional
import numpy as np
from autograd import grad

class integrator:
    def __init__(self, lower: float, upper: float, stepsize: float): 
        self.lower = lower
        self.upper = upper
        self.stepsize = stepsize

    def rectangle_left(self, f):
        result = 0
        x = self.lower
        while x < self.upper:
            result += f(x) * self.stepsize
            x += self.stepsize
        return result

    def rectangle_right(self, f):
        result = 0
        x = self.lower + self.stepsize
        while x <= self.upper:
            result += f(x) * self.stepsize
            x += self.stepsize
        return result

    def rectangle_middle(self, f):
        result = 0
        x = self.lower + self.stepsize / 2
        while x < self.upper:
            result += f(x) * self.stepsize
            x += self.stepsize
        return result

    def M_search(self, f, num_points: Optional[int] = 100) -> float:
        second_derivative = grad(grad(f))
        x = np.linspace(self.lower, self.upper, num_points)
        return max(np.abs(second_derivative(x)))

    def middle_error(self, f):
        M = self.M_search(f) 
        return M * (self.upper - self.lower)**3  / (24 * self.stepsize**2 )

    def determine_stepsize_middle(self, f, error: float) -> int:
        M = self.M_search(f)
        return int(np.sqrt((M * (self.upper - self.lower)**3) / (24 * error))) + 1
        
    def trapezoid(self, f):
        result = 0
        x = self.lower
        while x < self.upper:
            result += (f(x) + f(x + self.stepsize)) * self.stepsize / 2
            x += self.stepsize
        return result

    def trapezoid_error(self, f):
        M = self.M_search(f)
        return M * (self.upper - self.lower)**3 / (12  * self.stepsize**2) 

    def determine_stepsize_trapezoid(self, f, error: float) -> int:
        M = self.M_search(f)
        return int(np.sqrt((M * (self.upper - self.lower)**3) / (12 * error))) + 1

    # EDIT: Add a new method here called `simpson`. It should take `self` and a function `f` as arguments.
    # Inside this new method, you will write the code to perform an integration using Simpson's rule.
    # The formula for Simpson's rule is (h/3) * [f(x_0) + 4f(x_1) + 2f(x_2) + ... + 4f(x_{n-1}) + f(x_n)],
    # where h is the stepsize and n is the number of intervals.
    # Follow these steps inside the method:
    # 1. Calculate the number of intervals, `n`, by dividing the integration range (`self.upper` - `self.lower`) by `self.stepsize`. Round this to the nearest integer.
    # 2. Simpson's rule requires an even number of intervals. Add a check to see if `n` is odd. If it is, raise a `ValueError` with an informative message.
    # 3. Initialize a variable, let's call it `total_sum`, to 0. This will hold the weighted sum of function values.
    # 4. Create a `for` loop that iterates with an index `i` from 0 to `n` (inclusive).
    # 5. Inside the loop, first calculate the current x-position for the index `i`.
    # 6. Next, determine the weight for the current point.
    #    - If it's an endpoint (i.e., `i` is 0 or `n`), the weight is 1.
    #    - If `i` is an odd number, the weight is 4.
    #    - If `i` is an even number (and not an endpoint), the weight is 2.
    # 7. Add the function value at the current x-position, multiplied by its weight, to `total_sum`.
    # 8. After the loop finishes, calculate the final integral by multiplying `total_sum` by `self.stepsize / 3`.
    # 9. Return this final integral value.
```
