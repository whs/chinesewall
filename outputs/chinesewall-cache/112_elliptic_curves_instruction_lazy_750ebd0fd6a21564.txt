[5762, 5771]
import random

def is_prime(n):
    """Check if a number is prime."""
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

class EllipticCurve:
    def __init__(self, a : int, b : int, p : int):
        self.a = a 
        self.b = b
        assert is_prime(p), "p is not prime"
        self.p = p # prime

    def is_on_curve(self, x : int, y : int) -> bool:
        return (y**2 - x**3 - self.a*x - self.b) % self.p == 0

    def mod_inverse(self, value: int) -> int:
        """ uses fermat's little theorem for modular inverse """
        return pow(value, self.p - 2, self.p)

    def point_addition(self, P: tuple, Q: tuple) -> tuple:
        """ returns the sum of the two points, P, Q 
            uses (None, None) to represent infinity """
        # cases where either point are infinity
        if P == (None, None) : return Q
        if Q == (None, None) : return P

        # P + (-P) = 0 or if the y coordinate is 0, return point at infinity
        if P[0] == Q[0] and (P[1] != Q[1] or P[1] == 0) : return (None, None)

        if P != Q:
            # The lambda (slope) calculation for two distinct points
            m = (Q[1] - P[1]) * self.mod_inverse(Q[0] - P[0] + self.p) % self.p
        else:
            # The lambda (slope) calculation for point doubling
            m = (3 * P[0]**2 + self.a) * self.mod_inverse(2 * P[1]) % self.p

        x_r = (m**2 - P[0] - Q[0]) % self.p
        y_r = (m * (P[0] - x_r) - P[1]) % self.p

        return (x_r, y_r)
    
    def point_double(self, P: tuple) -> tuple:
        """ double the given point """
        return self.point_addition(P, P)

    def point_multiplication(self, k: int, P: tuple) -> tuple:
        """scalar multiplication of P by k."""
        if P == (None, None) or k == 0:
            return (None, None)

        result = (None, None)  # Initialize result as the identity element (infinity point)
        addend = P

        while k:
            if k & 1:
                result = self.point_addition(result, addend)
            addend = self.point_addition(addend, addend)
            k >>= 1

        return result

    # EDIT: Add a new method here called `windowed_point_multiplication`.
    # It should accept `self`, an integer `k`, a point `P`, and an integer `w` (for window size) as arguments.
    # It should return a tuple representing the resulting point.
    # This method will perform scalar multiplication using a windowing optimization.

        # EDIT: First, handle the base cases. If `k` is 0 or `P` is the point at infinity `(None, None)`, the result is the point at infinity. Return `(None, None)`.

        # EDIT: Second, perform the precomputation step. We need to compute and store points for `1*P`, `2*P`, ..., up to `(2^w - 1)*P`.
        # 1. Create a list called `precomputed_points`.
        # 2. To make lookups easy, store the point for `d*P` at index `d`. Start by adding the point at infinity `(None, None)` for index 0.
        # 3. Add the base point `P` to the list for index 1.
        # 4. Loop from `i = 2` up to `2**w - 1`.
        # 5. In each step, calculate the next point `i*P` by adding `P` to the previously computed point `(i-1)*P`, which is stored at `precomputed_points[i-1]`.
        # 6. Append the new point to the `precomputed_points` list.

        # EDIT: Third, implement the main loop using the precomputed values. This is a modified double-and-add algorithm.
        # 1. Initialize a `result` variable to the point at infinity, `(None, None)`.
        # 2. Get the binary representation of `k` as a string, removing the '0b' prefix (e.g., using `bin(k)[2:]`).
        # 3. We need to process the binary string in chunks of size `w`. If the length of the binary string is not a multiple of `w`, pad it with leading zeros until it is.
        # 4. Initialize an index `i` to 0.
        # 5. Loop through the padded binary string as long as `i` is less than its length.
        #    a. In each iteration, first, "double" the current `result` `w` times. You can do this with a `for` loop that calls `self.point_double(result)` `w` times.
        #    b. Get the current chunk (window) of `w` bits from the binary string, starting at index `i`.
        #    c. Convert this binary chunk from a string into an integer. Let's call it `d`.
        #    d. If `d` is not 0, it means we need to add a precomputed point. Add the point `precomputed_points[d]` to the `result` using `self.point_addition`.
        #    e. Move to the next window by increasing `i` by `w`.
        # 6. After the loop finishes, return the final `result`.

    def generate_keypair(self, G: tuple, n: int, d : int) -> tuple:
        """ Given an initial point G and an order n, construct a keypair, and d, the private key """
        assert 1 <= d and d <= n-1
        # EDIT: Replace the call to `point_multiplication` below with a call to your new `windowed_point_multiplication` method.
        # Use a window size `w` of 4.
        Q = self.point_multiplication(d, G) # public key
        return (d, Q) 

    def validate_keypair(self, d: int, Q: tuple, G: tuple, n: int) -> bool:
        """ Validate the given keypair, given an initial point G,
            a public key Q, a private key d, and a group order n """
        if not (1 <= d < n) : return False
        if not self.is_on_curve(Q[0], Q[1]) : return False
        # EDIT: To validate the keypair, we must re-calculate the public key from the private key and see if it matches.
        # Replace the call to `point_multiplication` below with a call to your new `windowed_point_multiplication` method.
        # Use a window size `w` of 4.
        return self.point_multiplication(d, G) == Q

===============
```py
import random

def is_prime(n):
    """Check if a number is prime."""
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

class EllipticCurve:
    def __init__(self, a : int, b : int, p : int):
        self.a = a 
        self.b = b
        assert is_prime(p), "p is not prime"
        self.p = p # prime

    def is_on_curve(self, x : int, y : int) -> bool:
        return (y**2 - x**3 - self.a*x - self.b) % self.p == 0

    def mod_inverse(self, value: int) -> int:
        """ uses fermat's little theorem for modular inverse """
        return pow(value, self.p - 2, self.p)

    def point_addition(self, P: tuple, Q: tuple) -> tuple:
        """ returns the sum of the two points, P, Q 
            uses (None, None) to represent infinity """
        # cases where either point are infinity
        if P == (None, None) : return Q
        if Q == (None, None) : return P

        # P + (-P) = 0 or if the y coordinate is 0, return point at infinity
        if P[0] == Q[0] and (P[1] != Q[1] or P[1] == 0) : return (None, None)

        if P != Q:
            # The lambda (slope) calculation for two distinct points
            m = (Q[1] - P[1]) * self.mod_inverse(Q[0] - P[0] + self.p) % self.p
        else:
            # The lambda (slope) calculation for point doubling
            m = (3 * P[0]**2 + self.a) * self.mod_inverse(2 * P[1]) % self.p

        x_r = (m**2 - P[0] - Q[0]) % self.p
        y_r = (m * (P[0] - x_r) - P[1]) % self.p

        return (x_r, y_r)
    
    def point_double(self, P: tuple) -> tuple:
        """ double the given point """
        return self.point_addition(P, P)

    def point_multiplication(self, k: int, P: tuple) -> tuple:
        """scalar multiplication of P by k."""
        if P == (None, None) or k == 0:
            return (None, None)

        result = (None, None)  # Initialize result as the identity element (infinity point)
        addend = P

        while k:
            if k & 1:
                result = self.point_addition(result, addend)
            addend = self.point_addition(addend, addend)
            k >>= 1

        return result

    # EDIT: Add a new method here called `windowed_point_multiplication`.
    # It should accept `self`, an integer `k`, a point `P`, and an integer `w` (for window size) as arguments.
    # It should return a tuple representing the resulting point.
    # This method will perform scalar multiplication using a windowing optimization.

        # EDIT: First, handle the base cases. If `k` is 0 or `P` is the point at infinity `(None, None)`, the result is the point at infinity. Return `(None, None)`.

        # EDIT: Second, perform the precomputation step. We need to compute and store points for `1*P`, `2*P`, ..., up to `(2^w - 1)*P`.
        # 1. Create a list called `precomputed_points`.
        # 2. To make lookups easy, store the point for `d*P` at index `d`. Start by adding the point at infinity `(None, None)` for index 0.
        # 3. Add the base point `P` to the list for index 1.
        # 4. Loop from `i = 2` up to `2**w - 1`.
        # 5. In each step, calculate the next point `i*P` by adding `P` to the previously computed point `(i-1)*P`, which is stored at `precomputed_points[i-1]`.
        # 6. Append the new point to the `precomputed_points` list.

        # EDIT: Third, implement the main loop using the precomputed values. This is a modified double-and-add algorithm.
        # 1. Initialize a `result` variable to the point at infinity, `(None, None)`.
        # 2. Get the binary representation of `k` as a string, removing the '0b' prefix (e.g., using `bin(k)[2:]`).
        # 3. We need to process the binary string in chunks of size `w`. If the length of the binary string is not a multiple of `w`, pad it with leading zeros until it is.
        # 4. Initialize an index `i` to 0.
        # 5. Loop through the padded binary string as long as `i` is less than its length.
        #    a. In each iteration, first, "double" the current `result` `w` times. You can do this with a `for` loop that calls `self.point_double(result)` `w` times.
        #    b. Get the current chunk (window) of `w` bits from the binary string, starting at index `i`.
        #    c. Convert this binary chunk from a string into an integer. Let's call it `d`.
        #    d. If `d` is not 0, it means we need to add a precomputed point. Add the point `precomputed_points[d]` to the `result` using `self.point_addition`.
        #    e. Move to the next window by increasing `i` by `w`.
        # 6. After the loop finishes, return the final `result`.

    def generate_keypair(self, G: tuple, n: int, d : int) -> tuple:
        """ Given an initial point G and an order n, construct a keypair, and d, the private key """
        assert 1 <= d and d <= n-1
        # EDIT: Replace the call to `point_multiplication` below with a call to your new `windowed_point_multiplication` method.
        # Use a window size `w` of 4.
        Q = self.point_multiplication(d, G) # public key
        return (d, Q) 

    def validate_keypair(self, d: int, Q: tuple, G: tuple, n: int) -> bool:
        """ Validate the given keypair, given an initial point G,
            a public key Q, a private key d, and a group order n """
        if not (1 <= d < n) : return False
        if not self.is_on_curve(Q[0], Q[1]) : return False
        # EDIT: To validate the keypair, we must re-calculate the public key from the private key and see if it matches.
        # Replace the call to `point_multiplication` below with a call to your new `windowed_point_multiplication` method.
        # Use a window size `w` of 4.
        return self.point_multiplication(d, G) == Q
```
