[5981, 5990]
from copy import deepcopy
from typing import Optional


class DPLLSolver:
    def __init__(self, cnf):
        """
        initializes the DPLL Solver with a given CNF (Conjunctive Normal Form) input.

        :param cnf: a string representing the CNF, where each clause is on a new line,
                    literals are separated by spaces, negation is denoted by '!', and
                    variables are single characters.
        """
        self.assign_true = set()  # set of literals assigned True
        self.assign_false = set()  # set of literals assigned False
        self.n_props = 0          # count of propositions made
        self.n_splits = 0         # count of splits (decisions) made
        self.cnf = cnf            # the CNF input

    def print_cnf(self):
        """
        prints the CNF in a more readable format, where clauses are enclosed in parentheses
        and literals are separated by '+'.
        """
        s = ''
        for i in self.cnf:
            if len(i) > 0:
                s += '(' + i.replace(' ', '+') + ')'
        print(s)

    def solve(self, cnf, literals):
        """
        recursively solves the CNF using the DPLL algorithm.

        :param cnf: the CNF in its current state (as clauses get simplified).
        :param literals: list of literals that haven't been assigned yet.
        :return: True if the CNF is satisfiable, False otherwise.
        """
        new_true = []  # literals assigned True in this decision level
        new_false = []  # literals assigned False in this decision level
        self.n_splits += 1
        cnf = list(set(cnf))  # remove duplicate clauses
        units = [i for i in cnf if len(i) < 3]  # unit clauses
        units = list(set(units))  # remove duplicate units

        # Unit Propagation
        if len(units):
            for unit in units:
                self.n_props += 1
                if '!' in unit:
                    self.assign_false.add(unit[-1])
                    new_false.append(unit[-1])
                    # simplify the CNF by removing clauses and literals
                    i = 0
                    while True:
                        if unit in cnf[i]:
                            cnf.remove(cnf[i])
                            i -= 1
                        elif unit[-1] in cnf[i]:
                            cnf[i] = cnf[i].replace(unit[-1], '').strip()
                        i += 1
                        if i >= len(cnf):
                            break
                else:
                    self.assign_true.add(unit)
                    new_true.append(unit)
                    i = 0
                    while True:
                        if '!'+unit in cnf[i]:
                            cnf[i] = cnf[i].replace('!'+unit, '').strip()
                        elif unit in cnf[i]:
                            cnf.remove(cnf[i])
                            i -= 1
                        i += 1
                        if i >= len(cnf):
                            break

        # EDIT: Check for a contradiction. An empty clause, represented by an empty string '',
        # means the current set of assignments is impossible.
        # If you find an empty string in the `cnf` list, you must backtrack by returning False.
        # Add a conditional statement here to check if `'' in cnf`.

        # check if CNF is solved
        if len(cnf) == 0:
            return True

        # splitting (choose a literal and try both True and False)
        literals = [k for k in list(set(''.join(cnf))) if k.isalpha()]
        x = literals[0]
        # EDIT: Before trying the two different paths for the literal `x`, you need to save the
        # current state of assignments. This is because the recursive calls will modify the shared
        # assignment sets (`self.assign_true`, `self.assign_false`), and if a path fails, we need
        # to revert those changes before trying another path.
        # Create copies of `self.assign_true` and `self.assign_false` and store them in local variables
        # (e.g., `saved_true_assignments`, `saved_false_assignments`). Use the `.copy()` method for this.
        if self.solve(deepcopy(cnf) + [x], deepcopy(literals)):
            return True
        # EDIT: The first path (assuming `x` is True) failed. Before trying the second path
        # (assuming `x` is False), you must restore the assignment sets to the state you saved earlier.
        # This ensures the second path starts from the same state as the first one did.
        # Set `self.assign_true` and `self.assign_false` back to the saved copies.
        elif self.solve(deepcopy(cnf) + ['!' + x], deepcopy(literals)):
            return True
        else:
            # undo assignments made in this decision level
            for i in new_false:
                self.assign_false.remove(i)
            # EDIT: The cleanup logic here is incomplete. It only undoes the 'false' assignments
            # (`new_false`) made during unit propagation at this level. You must also undo the
            # 'true' assignments stored in `new_true`.
            # Add a `for` loop that iterates through `new_true` and removes each item from `self.assign_true`.
            return False

    def dpll(self) -> Optional[dict]:
        """
        public method to solve the CNF using the DPLL algorithm.

        :return: a dictionary mapping each literal to its boolean value if the CNF is satisfiable,
                 or None if the CNF is unsatisfiable.
        """
        literals = [i for i in list(set(self.cnf)) if i.isalpha()]
        cnf = self.cnf.splitlines()
        res = {}
        if self.solve(cnf, literals):
            # assign values to literals based on the assignments made during solving
            for i in self.assign_true:
                res[i] = True
            for i in self.assign_false:
                res[i] = False

            return res
        else:
            return None  # unsat!

===============
```py
from copy import deepcopy
from typing import Optional


class DPLLSolver:
    def __init__(self, cnf):
        """
        initializes the DPLL Solver with a given CNF (Conjunctive Normal Form) input.

        :param cnf: a string representing the CNF, where each clause is on a new line,
                    literals are separated by spaces, negation is denoted by '!', and
                    variables are single characters.
        """
        self.assign_true = set()  # set of literals assigned True
        self.assign_false = set()  # set of literals assigned False
        self.n_props = 0          # count of propositions made
        self.n_splits = 0         # count of splits (decisions) made
        self.cnf = cnf            # the CNF input

    def print_cnf(self):
        """
        prints the CNF in a more readable format, where clauses are enclosed in parentheses
        and literals are separated by '+'.
        """
        s = ''
        for i in self.cnf:
            if len(i) > 0:
                s += '(' + i.replace(' ', '+') + ')'
        print(s)

    def solve(self, cnf, literals):
        """
        recursively solves the CNF using the DPLL algorithm.

        :param cnf: the CNF in its current state (as clauses get simplified).
        :param literals: list of literals that haven't been assigned yet.
        :return: True if the CNF is satisfiable, False otherwise.
        """
        new_true = []  # literals assigned True in this decision level
        new_false = []  # literals assigned False in this decision level
        self.n_splits += 1
        cnf = list(set(cnf))  # remove duplicate clauses
        units = [i for i in cnf if len(i) < 3]  # unit clauses
        units = list(set(units))  # remove duplicate units

        # Unit Propagation
        if len(units):
            for unit in units:
                self.n_props += 1
                if '!' in unit:
                    self.assign_false.add(unit[-1])
                    new_false.append(unit[-1])
                    # simplify the CNF by removing clauses and literals
                    i = 0
                    while True:
                        if unit in cnf[i]:
                            cnf.remove(cnf[i])
                            i -= 1
                        elif unit[-1] in cnf[i]:
                            cnf[i] = cnf[i].replace(unit[-1], '').strip()
                        i += 1
                        if i >= len(cnf):
                            break
                else:
                    self.assign_true.add(unit)
                    new_true.append(unit)
                    i = 0
                    while True:
                        if '!'+unit in cnf[i]:
                            cnf[i] = cnf[i].replace('!'+unit, '').strip()
                        elif unit in cnf[i]:
                            cnf.remove(cnf[i])
                            i -= 1
                        i += 1
                        if i >= len(cnf):
                            break

        # EDIT: Check for a contradiction. An empty clause, represented by an empty string '',
        # means the current set of assignments is impossible.
        # If you find an empty string in the `cnf` list, you must backtrack by returning False.
        # Add a conditional statement here to check if `'' in cnf`.

        # check if CNF is solved
        if len(cnf) == 0:
            return True

        # splitting (choose a literal and try both True and False)
        literals = [k for k in list(set(''.join(cnf))) if k.isalpha()]
        x = literals[0]
        # EDIT: Before trying the two different paths for the literal `x`, you need to save the
        # current state of assignments. This is because the recursive calls will modify the shared
        # assignment sets (`self.assign_true`, `self.assign_false`), and if a path fails, we need
        # to revert those changes before trying another path.
        # Create copies of `self.assign_true` and `self.assign_false` and store them in local variables
        # (e.g., `saved_true_assignments`, `saved_false_assignments`). Use the `.copy()` method for this.
        if self.solve(deepcopy(cnf) + [x], deepcopy(literals)):
            return True
        # EDIT: The first path (assuming `x` is True) failed. Before trying the second path
        # (assuming `x` is False), you must restore the assignment sets to the state you saved earlier.
        # This ensures the second path starts from the same state as the first one did.
        # Set `self.assign_true` and `self.assign_false` back to the saved copies.
        elif self.solve(deepcopy(cnf) + ['!' + x], deepcopy(literals)):
            return True
        else:
            # undo assignments made in this decision level
            for i in new_false:
                self.assign_false.remove(i)
            # EDIT: The cleanup logic here is incomplete. It only undoes the 'false' assignments
            # (`new_false`) made during unit propagation at this level. You must also undo the
            # 'true' assignments stored in `new_true`.
            # Add a `for` loop that iterates through `new_true` and removes each item from `self.assign_true`.
            return False

    def dpll(self) -> Optional[dict]:
        """
        public method to solve the CNF using the DPLL algorithm.

        :return: a dictionary mapping each literal to its boolean value if the CNF is satisfiable,
                 or None if the CNF is unsatisfiable.
        """
        literals = [i for i in list(set(self.cnf)) if i.isalpha()]
        cnf = self.cnf.splitlines()
        res = {}
        if self.solve(cnf, literals):
            # assign values to literals based on the assignments made during solving
            for i in self.assign_true:
                res[i] = True
            for i in self.assign_false:
                res[i] = False

            return res
        else:
            return None  # unsat!
```
