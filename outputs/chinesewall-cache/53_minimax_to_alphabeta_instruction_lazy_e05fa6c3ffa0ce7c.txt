[8474, 8483]
import copy
from typing import List, Literal, Optional, Tuple

Player = Literal['X', 'O']
WinStatus = Literal[Player, 'TIE', None]


class ConnectNGame:
    """
    A game of Connect N, of width x height, where N is the number of pieces in a row/column/diagonal to win.
    """

    def __init__(self, width, height, n):
        self.width = width
        self.height = height
        self.n = n
        self.board = [[' ' for _ in range(width)] for _ in range(height)]

    def __str__(self):
        return '\n'.join(['|' + '|'.join(row) + '|' for row in self.board])

    def drop(self, column, player: Player) -> bool:
        if column < 0 or column >= self.width:
            return False
        for row in range(self.height - 1, -1, -1):
            if self.board[row][column] == ' ':
                self.board[row][column] = player
                return True
        return False

    def is_won(self) -> WinStatus:
        # Check rows
        for row in self.board:
            for i in range(self.width - self.n + 1):
                if row[i] != ' ' and all(row[i] == row[j] for j in range(i + 1, i + self.n)):
                    return row[i]

        # Check columns
        for j in range(self.width):
            for i in range(self.height - self.n + 1):
                if self.board[i][j] != ' ' and all(self.board[i][j] == self.board[k][j] for k in range(i + 1, i + self.n)):
                    return self.board[i][j]

        # Check diagonals
        for i in range(self.height - self.n + 1):
            for j in range(self.width - self.n + 1):
                if self.board[i][j] != ' ' and all(self.board[i][j] == self.board[i + k][j + k] for k in range(1, self.n)):
                    return self.board[i][j]

        for i in range(self.height - self.n + 1):
            for j in range(self.n - 1, self.width):
                if self.board[i][j] != ' ' and all(self.board[i][j] == self.board[i + k][j - k] for k in range(1, self.n)):
                    return self.board[i][j]

        # Check for tie
        if all(self.board[i][j] != ' ' for i in range(self.height) for j in range(self.width)):
            return 'TIE'

        return None

    def possible_moves(self) -> List[int]:
        return [col for col in range(self.width) if self.board[0][col] == ' ']

    def heuristic(self, player: Player) -> float:
        """
        Returns a heuristic score [-0.9, 0.9] for the board state.
        """
        score = 0

        # center column preference
        center_column = [self.board[i][self.width // 2]
                         for i in range(self.height)]
        center_count = center_column.count(player)
        score += center_count * 0.3

        # check rows, columns, and diagonals for potential wins
        for row in range(self.height):
            for col in range(self.width):
                if self.board[row][col] == ' ':
                    continue

                # horizontal potential
                if col + self.n <= self.width:
                    window = [self.board[row][c]
                              for c in range(col, col + self.n)]
                    score += self.evaluate_window(window, player)

                # vertical potential
                if row + self.n <= self.height:
                    window = [self.board[r][col]
                              for r in range(row, row + self.n)]
                    score += self.evaluate_window(window, player)

                # positive diagonal
                if col + self.n <= self.width and row + self.n <= self.height:
                    window = [self.board[row + i][col + i]
                              for i in range(self.n)]
                    score += self.evaluate_window(window, player)

                # negative diagonal
                if col - self.n >= -1 and row + self.n <= self.height:
                    window = [self.board[row + i][col - i]
                              for i in range(self.n)]
                    score += self.evaluate_window(window, player)

        return score

    def evaluate_window(self, window, player):
        opponent = 'O' if player == 'X' else 'X'
        score = 0
        if window.count(player) == self.n - 1 and window.count(' ') == 1:
            score += 0.5
        if window.count(player) == self.n - 2 and window.count(' ') == 2:
            score += 0.2
        if window.count(opponent) == self.n - 1 and window.count(' ') == 1:
            score -= 0.4
        return score

    def score_position(self, status: WinStatus, player: Player) -> float:
        """
        Assign scores to the board state. 
        Win is 1, loss is -1, tie (or ongoing) is heuristic.
        """
        status = self.is_won()
        if status == player:
            return 1
        elif status == 'TIE':
            return 0
        elif status is None:
            return self.heuristic(player)
        else:
            return -1

    # EDIT: To implement Alpha-Beta pruning, which makes the AI faster by not searching unnecessary moves, add two new parameters to this function: `alpha` and `beta`. Both should have a type hint of `float`.
    def ai(self, depth: int, maximizing: bool, player: Player) -> Tuple[float, Optional[int]]:
        """ 
        Implements an AI that picks the "best" move using Minimax.
        Returns a tuple of (score, column).
        """
        opponent = 'O' if player == 'X' else 'X'

        if depth == 0:
            return self.score_position(self.is_won(), player), None
        terminal_status = self.is_won()
        if terminal_status is not None:
            return self.score_position(terminal_status, player), None

        moves = self.possible_moves()

        if maximizing:
            max_score = float('-inf')
            best_column = None
            for move in moves:
                temp_game = copy.deepcopy(self)
                temp_game.drop(move, player)
                # EDIT: The recursive call to `ai` needs to pass along the current `alpha` and `beta` values. Modify the line below to pass `alpha` and `beta`.
                score, _ = temp_game.ai(depth - 1, False, opponent)
                if score > max_score:
                    max_score = score
                    best_column = move
                # EDIT: Update `alpha`, which tracks the best score for the maximizing player. Set `alpha` to be the maximum of its current value and `max_score`.
                # EDIT: Now, check if we can "prune" this branch of the search tree. If `alpha` is greater than or equal to `beta`, the opponent (a minimizer) would have already avoided this path because it's too good for us. We can stop checking other moves in this branch. Add a condition to `break` out of the loop if `alpha >= beta`.
            return max_score, best_column
        else:
            min_score = float('inf')
            best_column = None
            for move in moves:
                temp_game = copy.deepcopy(self)
                temp_game.drop(move, opponent)
                # EDIT: The recursive call to `ai` needs to pass along the current `alpha` and `beta` values. Modify the line below to pass `alpha` and `beta`.
                score, _ = temp_game.ai(depth - 1, True, player)
                if score < min_score:
                    min_score = score
                    best_column = move
                # EDIT: Update `beta`, which tracks the best score for the minimizing player. Set `beta` to be the minimum of its current value and `min_score`.
                # EDIT: Now, check if we can "prune" this branch. If `beta` is less than or equal to `alpha`, the maximizing player would have already found a better path and would not choose this one. We can stop checking other moves in this branch. Add a condition to `break` out of the loop if `beta <= alpha`.
            return min_score, best_column

    def best_move(self, player: Player, depth=4) -> int:
        """ Returns the best column for the player using Minimax. """
        # EDIT: The first call to the AI needs to provide the starting values for alpha and beta. Alpha (the maximizer's best score) starts at negative infinity. Beta (the minimizer's best score) starts at positive infinity. Modify the `ai` call below to include `alpha=float('-inf')` and `beta=float('inf')`.
        _, best_column = self.ai(depth, False, player)
        if best_column is None:
            best_column = self.possible_moves()[0]
        return best_column

===============
```py
import copy
from typing import List, Literal, Optional, Tuple

Player = Literal['X', 'O']
WinStatus = Literal[Player, 'TIE', None]


class ConnectNGame:
    """
    A game of Connect N, of width x height, where N is the number of pieces in a row/column/diagonal to win.
    """

    def __init__(self, width, height, n):
        self.width = width
        self.height = height
        self.n = n
        self.board = [[' ' for _ in range(width)] for _ in range(height)]

    def __str__(self):
        return '\n'.join(['|' + '|'.join(row) + '|' for row in self.board])

    def drop(self, column, player: Player) -> bool:
        if column < 0 or column >= self.width:
            return False
        for row in range(self.height - 1, -1, -1):
            if self.board[row][column] == ' ':
                self.board[row][column] = player
                return True
        return False

    def is_won(self) -> WinStatus:
        # Check rows
        for row in self.board:
            for i in range(self.width - self.n + 1):
                if row[i] != ' ' and all(row[i] == row[j] for j in range(i + 1, i + self.n)):
                    return row[i]

        # Check columns
        for j in range(self.width):
            for i in range(self.height - self.n + 1):
                if self.board[i][j] != ' ' and all(self.board[i][j] == self.board[k][j] for k in range(i + 1, i + self.n)):
                    return self.board[i][j]

        # Check diagonals
        for i in range(self.height - self.n + 1):
            for j in range(self.width - self.n + 1):
                if self.board[i][j] != ' ' and all(self.board[i][j] == self.board[i + k][j + k] for k in range(1, self.n)):
                    return self.board[i][j]

        for i in range(self.height - self.n + 1):
            for j in range(self.n - 1, self.width):
                if self.board[i][j] != ' ' and all(self.board[i][j] == self.board[i + k][j - k] for k in range(1, self.n)):
                    return self.board[i][j]

        # Check for tie
        if all(self.board[i][j] != ' ' for i in range(self.height) for j in range(self.width)):
            return 'TIE'

        return None

    def possible_moves(self) -> List[int]:
        return [col for col in range(self.width) if self.board[0][col] == ' ']

    def heuristic(self, player: Player) -> float:
        """
        Returns a heuristic score [-0.9, 0.9] for the board state.
        """
        score = 0

        # center column preference
        center_column = [self.board[i][self.width // 2]
                         for i in range(self.height)]
        center_count = center_column.count(player)
        score += center_count * 0.3

        # check rows, columns, and diagonals for potential wins
        for row in range(self.height):
            for col in range(self.width):
                if self.board[row][col] == ' ':
                    continue

                # horizontal potential
                if col + self.n <= self.width:
                    window = [self.board[row][c]
                              for c in range(col, col + self.n)]
                    score += self.evaluate_window(window, player)

                # vertical potential
                if row + self.n <= self.height:
                    window = [self.board[r][col]
                              for r in range(row, row + self.n)]
                    score += self.evaluate_window(window, player)

                # positive diagonal
                if col + self.n <= self.width and row + self.n <= self.height:
                    window = [self.board[row + i][col + i]
                              for i in range(self.n)]
                    score += self.evaluate_window(window, player)

                # negative diagonal
                if col - self.n >= -1 and row + self.n <= self.height:
                    window = [self.board[row + i][col - i]
                              for i in range(self.n)]
                    score += self.evaluate_window(window, player)

        return score

    def evaluate_window(self, window, player):
        opponent = 'O' if player == 'X' else 'X'
        score = 0
        if window.count(player) == self.n - 1 and window.count(' ') == 1:
            score += 0.5
        if window.count(player) == self.n - 2 and window.count(' ') == 2:
            score += 0.2
        if window.count(opponent) == self.n - 1 and window.count(' ') == 1:
            score -= 0.4
        return score

    def score_position(self, status: WinStatus, player: Player) -> float:
        """
        Assign scores to the board state. 
        Win is 1, loss is -1, tie (or ongoing) is heuristic.
        """
        status = self.is_won()
        if status == player:
            return 1
        elif status == 'TIE':
            return 0
        elif status is None:
            return self.heuristic(player)
        else:
            return -1

    # EDIT: To implement Alpha-Beta pruning, which makes the AI faster by not searching unnecessary moves, add two new parameters to this function: `alpha` and `beta`. Both should have a type hint of `float`.
    def ai(self, depth: int, maximizing: bool, player: Player) -> Tuple[float, Optional[int]]:
        """ 
        Implements an AI that picks the "best" move using Minimax.
        Returns a tuple of (score, column).
        """
        opponent = 'O' if player == 'X' else 'X'

        if depth == 0:
            return self.score_position(self.is_won(), player), None
        terminal_status = self.is_won()
        if terminal_status is not None:
            return self.score_position(terminal_status, player), None

        moves = self.possible_moves()

        if maximizing:
            max_score = float('-inf')
            best_column = None
            for move in moves:
                temp_game = copy.deepcopy(self)
                temp_game.drop(move, player)
                # EDIT: The recursive call to `ai` needs to pass along the current `alpha` and `beta` values. Modify the line below to pass `alpha` and `beta`.
                score, _ = temp_game.ai(depth - 1, False, opponent)
                if score > max_score:
                    max_score = score
                    best_column = move
                # EDIT: Update `alpha`, which tracks the best score for the maximizing player. Set `alpha` to be the maximum of its current value and `max_score`.
                # EDIT: Now, check if we can "prune" this branch of the search tree. If `alpha` is greater than or equal to `beta`, the opponent (a minimizer) would have already avoided this path because it's too good for us. We can stop checking other moves in this branch. Add a condition to `break` out of the loop if `alpha >= beta`.
            return max_score, best_column
        else:
            min_score = float('inf')
            best_column = None
            for move in moves:
                temp_game = copy.deepcopy(self)
                temp_game.drop(move, opponent)
                # EDIT: The recursive call to `ai` needs to pass along the current `alpha` and `beta` values. Modify the line below to pass `alpha` and `beta`.
                score, _ = temp_game.ai(depth - 1, True, player)
                if score < min_score:
                    min_score = score
                    best_column = move
                # EDIT: Update `beta`, which tracks the best score for the minimizing player. Set `beta` to be the minimum of its current value and `min_score`.
                # EDIT: Now, check if we can "prune" this branch. If `beta` is less than or equal to `alpha`, the maximizing player would have already found a better path and would not choose this one. We can stop checking other moves in this branch. Add a condition to `break` out of the loop if `beta <= alpha`.
            return min_score, best_column

    def best_move(self, player: Player, depth=4) -> int:
        """ Returns the best column for the player using Minimax. """
        # EDIT: The first call to the AI needs to provide the starting values for alpha and beta. Alpha (the maximizer's best score) starts at negative infinity. Beta (the minimizer's best score) starts at positive infinity. Modify the `ai` call below to include `alpha=float('-inf')` and `beta=float('inf')`.
        _, best_column = self.ai(depth, False, player)
        if best_column is None:
            best_column = self.possible_moves()[0]
        return best_column
```
