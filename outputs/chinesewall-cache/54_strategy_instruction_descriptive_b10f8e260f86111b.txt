[3430, 3439]
from abc import ABC
from abc import abstractmethod
from typing import List, Tuple

class Strategy(ABC):
    @abstractmethod
    def returnMove(self, board: List[List[bool]]) -> Tuple[int, int]:
        '''Returns a tuple(row, column) which indicates where to move 
           in a 3x3 grid.'''
        pass

class CornerStrategy(Strategy):
    def returnMove(self, board: List[List[bool]]) -> Tuple[int, int]:
        if board[0][0] == None:
            return (0, 0)
        elif board[0][2] == None:
            return (0, 2)
        elif board[2][0] == None:
            return (2, 0)
        elif board[2][2] == None:
            return (2, 2)
        else:
            raise Exception
        
class Game:
    def __init__(self, player1: Strategy, player2: Strategy):
        self.playerOne = player1
        self.playerTwo = player2
        self.board = [[None for _ in range(3)] for _ in range(3)]

    def player1Won(self):
        playerTurn = True
        while not self.playerXWon(True) and not self.playerXWon(False) and not self.gameOver():
             strat = self.playerOne if playerTurn else self.playerTwo
             move = strat.returnMove(self.board)
             self.board[move[0]][move[1]] = playerTurn
             playerTurn = not playerTurn
        if self.gameOver():
            return False
        else:
            return self.playerXWon(True)


    def gameOver(self):
        for row in self.board:
            for col in row:
                if col == None:
                    return False
        return True
    
    def playerXWon(self, x: bool):
        for i in range(3):
            if self.rowNX(i, x):
                return True
        for i in range(3):
            if self.colNX(i, x):
                return True
        downDiag = self.board[0][0] == x and self.board[1][1] == x and self.board[2][2] == x
        upDiag = self.board[2][0] == x and self.board[1][1] == x and self.board[0][2] == x
        return downDiag or upDiag
    


    def rowNX(self, n: int, x: bool):
        for col in self.board[n]:
            if col != x:
                return False
        return True
    def colNX(self, n: int, x: bool):
        for row in self.board:
            if row[n] != x:
                return False
        return True

# EDIT: Create a new class called `GoodStrategy` that inherits from the `Strategy` class.
# EDIT: Inside the `GoodStrategy` class, define the `returnMove` method. This method must have the same parameters and type hints as the one in the parent `Strategy` class.
# EDIT: Inside the `returnMove` method, you will implement a specific sequence of moves to win the game.
# EDIT: 1. Add an `if` statement to check if the center square of the board (at row 1, column 1) is empty (equal to `None`). If it is, return the tuple `(1, 1)`.
# EDIT: 2. Add an `elif` statement to check if the top-right corner (at row 0, column 2) is empty. If it is, return the tuple `(0, 2)`.
# EDIT: 3. Add another `elif` statement to check if the middle-left square (at row 1, column 0) is empty. If it is, return the tuple `(1, 0)`. This move is to block the opponent.
# EDIT: 4. Add a final `elif` statement to check if the middle-right square (at row 1, column 2) is empty. If it is, return the tuple `(1, 2)`. This is the winning move.
# EDIT: 5. Add an `else` block as a fallback. Inside this block, `raise` an `Exception`. This will handle any unexpected game states.

===============
```py
from abc import ABC
from abc import abstractmethod
from typing import List, Tuple

class Strategy(ABC):
    @abstractmethod
    def returnMove(self, board: List[List[bool]]) -> Tuple[int, int]:
        '''Returns a tuple(row, column) which indicates where to move 
           in a 3x3 grid.'''
        pass

class CornerStrategy(Strategy):
    def returnMove(self, board: List[List[bool]]) -> Tuple[int, int]:
        if board[0][0] == None:
            return (0, 0)
        elif board[0][2] == None:
            return (0, 2)
        elif board[2][0] == None:
            return (2, 0)
        elif board[2][2] == None:
            return (2, 2)
        else:
            raise Exception
        
class Game:
    def __init__(self, player1: Strategy, player2: Strategy):
        self.playerOne = player1
        self.playerTwo = player2
        self.board = [[None for _ in range(3)] for _ in range(3)]

    def player1Won(self):
        playerTurn = True
        while not self.playerXWon(True) and not self.playerXWon(False) and not self.gameOver():
             strat = self.playerOne if playerTurn else self.playerTwo
             move = strat.returnMove(self.board)
             self.board[move[0]][move[1]] = playerTurn
             playerTurn = not playerTurn
        if self.gameOver():
            return False
        else:
            return self.playerXWon(True)


    def gameOver(self):
        for row in self.board:
            for col in row:
                if col == None:
                    return False
        return True
    
    def playerXWon(self, x: bool):
        for i in range(3):
            if self.rowNX(i, x):
                return True
        for i in range(3):
            if self.colNX(i, x):
                return True
        downDiag = self.board[0][0] == x and self.board[1][1] == x and self.board[2][2] == x
        upDiag = self.board[2][0] == x and self.board[1][1] == x and self.board[0][2] == x
        return downDiag or upDiag
    


    def rowNX(self, n: int, x: bool):
        for col in self.board[n]:
            if col != x:
                return False
        return True
    def colNX(self, n: int, x: bool):
        for row in self.board:
            if row[n] != x:
                return False
        return True

# EDIT: Create a new class called `GoodStrategy` that inherits from the `Strategy` class.
# EDIT: Inside the `GoodStrategy` class, define the `returnMove` method. This method must have the same parameters and type hints as the one in the parent `Strategy` class.
# EDIT: Inside the `returnMove` method, you will implement a specific sequence of moves to win the game.
# EDIT: 1. Add an `if` statement to check if the center square of the board (at row 1, column 1) is empty (equal to `None`). If it is, return the tuple `(1, 1)`.
# EDIT: 2. Add an `elif` statement to check if the top-right corner (at row 0, column 2) is empty. If it is, return the tuple `(0, 2)`.
# EDIT: 3. Add another `elif` statement to check if the middle-left square (at row 1, column 0) is empty. If it is, return the tuple `(1, 0)`. This move is to block the opponent.
# EDIT: 4. Add a final `elif` statement to check if the middle-right square (at row 1, column 2) is empty. If it is, return the tuple `(1, 2)`. This is the winning move.
# EDIT: 5. Add an `else` block as a fallback. Inside this block, `raise` an `Exception`. This will handle any unexpected game states.
```
