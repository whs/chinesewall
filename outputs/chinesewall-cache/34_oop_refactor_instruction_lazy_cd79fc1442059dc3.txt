[3038, 3047]
# EDIT: Import the `ABC` (Abstract Base Class) and `abstractmethod` from the `abc` module. These are needed to define a template for other classes.

# EDIT: Define an abstract class named `Message` that inherits from `ABC`. An abstract class serves as a blueprint and cannot be instantiated on its own.
    # EDIT: Define the constructor, `__init__`, which runs when a new object is created.
    # It should accept `self` and a `content` parameter.
    # Inside the constructor, assign the `content` parameter to an instance attribute, for example, `self.content`.

    # EDIT: Define an abstract method named `process`. An abstract method must be implemented by any child class that inherits from `Message`.
    # Use the `@abstractmethod` decorator just above the method definition.
    # This method should accept `self` as its only parameter.
    # The body of this method should just be the `pass` keyword, as the actual logic will be in the child classes.

# EDIT: Define a new class named `TextMessage` that inherits from the `Message` class.
    # EDIT: Implement the `process` method for this class. It must have this method because it inherits from `Message`.
    # This method should return a formatted string: f"Processed text message: {self.content}". You can get the content from the `self.content` attribute.

# EDIT: Define a new class named `ImageMessage` that inherits from the `Message` class.
    # EDIT: Implement the `process` method for this class.
    # This method should return a formatted string: f"Processed image message with description: {self.content}".

# EDIT: Define a class named `MessageFactory`. This class will be responsible for creating message objects of the correct type.
    # EDIT: Define a static method named `get_message`. A static method is associated with the class, not a specific instance of it.
    # Use the `@staticmethod` decorator just above the method definition.
    # The method should accept two parameters: `message_type` and `content`.
    # Add type hints: `message_type` should be a `str`, `content` should be a `str`, and the method should return a `Message` object.
        # EDIT: Inside `get_message`, use an if/elif/else structure to check the value of `message_type`.
        # 1. If `message_type` is the string "text", return a new instance of `TextMessage`, passing `content` to its constructor.
        # 2. Else if `message_type` is the string "image", return a new instance of `ImageMessage`, passing `content` to its constructor.
        # 3. Otherwise, if the `message_type` is not supported, raise a `ValueError` with a descriptive message like "Unsupported message type".

# EDIT: This function will be replaced by the new classes. You can remove the entire function definition.
def process_message(message, message_type):
    if message_type == "text":
        return f"Processed text message: {message}"
    elif message_type == "image":
        return f"Processed image message with description: {message}"
    else:
        return "Unknown message type"

===============
```py
# EDIT: Import the `ABC` (Abstract Base Class) and `abstractmethod` from the `abc` module. These are needed to define a template for other classes.

# EDIT: Define an abstract class named `Message` that inherits from `ABC`. An abstract class serves as a blueprint and cannot be instantiated on its own.
    # EDIT: Define the constructor, `__init__`, which runs when a new object is created.
    # It should accept `self` and a `content` parameter.
    # Inside the constructor, assign the `content` parameter to an instance attribute, for example, `self.content`.

    # EDIT: Define an abstract method named `process`. An abstract method must be implemented by any child class that inherits from `Message`.
    # Use the `@abstractmethod` decorator just above the method definition.
    # This method should accept `self` as its only parameter.
    # The body of this method should just be the `pass` keyword, as the actual logic will be in the child classes.

# EDIT: Define a new class named `TextMessage` that inherits from the `Message` class.
    # EDIT: Implement the `process` method for this class. It must have this method because it inherits from `Message`.
    # This method should return a formatted string: f"Processed text message: {self.content}". You can get the content from the `self.content` attribute.

# EDIT: Define a new class named `ImageMessage` that inherits from the `Message` class.
    # EDIT: Implement the `process` method for this class.
    # This method should return a formatted string: f"Processed image message with description: {self.content}".

# EDIT: Define a class named `MessageFactory`. This class will be responsible for creating message objects of the correct type.
    # EDIT: Define a static method named `get_message`. A static method is associated with the class, not a specific instance of it.
    # Use the `@staticmethod` decorator just above the method definition.
    # The method should accept two parameters: `message_type` and `content`.
    # Add type hints: `message_type` should be a `str`, `content` should be a `str`, and the method should return a `Message` object.
        # EDIT: Inside `get_message`, use an if/elif/else structure to check the value of `message_type`.
        # 1. If `message_type` is the string "text", return a new instance of `TextMessage`, passing `content` to its constructor.
        # 2. Else if `message_type` is the string "image", return a new instance of `ImageMessage`, passing `content` to its constructor.
        # 3. Otherwise, if the `message_type` is not supported, raise a `ValueError` with a descriptive message like "Unsupported message type".

# EDIT: This function will be replaced by the new classes. You can remove the entire function definition.
def process_message(message, message_type):
    if message_type == "text":
        return f"Processed text message: {message}"
    elif message_type == "image":
        return f"Processed image message with description: {message}"
    else:
        return "Unknown message type"
```
