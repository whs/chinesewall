[4500, 4509]
from typing import Optional, Literal
from abc import ABC, abstractmethod


class Visitor(ABC):
    """
    A visitor.
    """

    @abstractmethod
    def visit(self, city_intersection: 'CityIntersection'):
        """
        Visit a city intersection.
        """


class City:
    """
    A city with a name, population, and typical traffic. The traffic is a
    float between 0 and 1 representing the percentage of the population that
    drives at any given time.
    """

    def __init__(self, name: str, population: int, traffic: float):
        self.name = name
        self.population = population
        self.traffic = traffic


# EDIT: Add a new intersection type called 'Roundabout' to this list of literal strings.
IntersectionType = Literal[
    'FourWayIntersection',
    'TIntersection',
]


class CityIntersection:
    """
    An intersection between cities. It contains a city, and two intersections.
    """

    def __init__(
        self,
        intersection1: Optional['CityIntersection'],
        intersection2: Optional['CityIntersection'],
        city: City,
        type: IntersectionType,
    ):
        self.intersection1 = intersection1
        self.intersection2 = intersection2
        self.city = city
        self.type = type

    def accept(self, visitor: Visitor):
        """
        Accepts a visitor.
        """
        visitor.visit(self)


class TrafficAnalysisVisitor(Visitor):
    """
    A visitor that performs complex traffic analysis on city intersections.
    """

    def __init__(self):
        self.traffic_data = {}

    def visit(self, city_intersection: 'CityIntersection'):
        """
        Perform traffic analysis on a city intersection and its children.
        """
        if city_intersection.type == 'FourWayIntersection':
            self.analyze_four_way_intersection(city_intersection)
        elif city_intersection.type == 'TIntersection':
            self.analyze_t_intersection(city_intersection)
        # EDIT: Add a new `elif` block here. Check if `city_intersection.type` is equal to the string 'Roundabout'. If it is, call a new method named `analyze_roundabout`, passing `city_intersection` to it.

        # EDIT: After the if/elif block, you need to make this method visit the connected intersections (the "children").
        # 1. Check if `city_intersection.intersection1` is not None.
        # 2. If it exists, call its `accept` method, passing `self` as the argument. This will make the visitor visit the first child intersection.
        # 3. Check if `city_intersection.intersection2` is not None.
        # 4. If it exists, call its `accept` method, passing `self` as the argument. This will make the visitor visit the second child intersection.

    def analyze_four_way_intersection(self, intersection: 'CityIntersection'):
        """
        Analyze traffic at a four-way intersection.
        """
        traffic_volume = intersection.city.population * intersection.city.traffic
        adjusted_traffic = traffic_volume * 1.2
        self.traffic_data[intersection.city.name] = {
            "type": intersection.type,
            "traffic_volume": adjusted_traffic
        }

    def analyze_t_intersection(self, intersection: 'CityIntersection'):
        """
        Analyze traffic at a T-intersection.
        """
        traffic_volume = intersection.city.population * intersection.city.traffic
        adjusted_traffic = traffic_volume * 1.1
        self.traffic_data[intersection.city.name] = {
            "type": intersection.type,
            "traffic_volume": adjusted_traffic
        }

    # EDIT: Create a new method here called `analyze_roundabout`. It should accept `self` and `intersection` (with type hint 'CityIntersection') as arguments.
    # Inside this method, you will perform the traffic analysis for a roundabout.
    # 1. Calculate the `traffic_volume` by multiplying the intersection's city population (`intersection.city.population`) by its traffic factor (`intersection.city.traffic`).
    # 2. Roundabouts reduce traffic by 30%. Calculate the `adjusted_traffic` by multiplying the `traffic_volume` by 0.7.
    # 3. Add the results to the `self.traffic_data` dictionary. The key should be the city's name (`intersection.city.name`).
    # 4. The value for this key should be another dictionary, containing two key-value pairs:
    #    - a key "type" with the value `intersection.type`
    #    - a key "traffic_volume" with the value of `adjusted_traffic` you calculated.

===============
```py
from typing import Optional, Literal
from abc import ABC, abstractmethod


class Visitor(ABC):
    """
    A visitor.
    """

    @abstractmethod
    def visit(self, city_intersection: 'CityIntersection'):
        """
        Visit a city intersection.
        """


class City:
    """
    A city with a name, population, and typical traffic. The traffic is a
    float between 0 and 1 representing the percentage of the population that
    drives at any given time.
    """

    def __init__(self, name: str, population: int, traffic: float):
        self.name = name
        self.population = population
        self.traffic = traffic


# EDIT: Add a new intersection type called 'Roundabout' to this list of literal strings.
IntersectionType = Literal[
    'FourWayIntersection',
    'TIntersection',
]


class CityIntersection:
    """
    An intersection between cities. It contains a city, and two intersections.
    """

    def __init__(
        self,
        intersection1: Optional['CityIntersection'],
        intersection2: Optional['CityIntersection'],
        city: City,
        type: IntersectionType,
    ):
        self.intersection1 = intersection1
        self.intersection2 = intersection2
        self.city = city
        self.type = type

    def accept(self, visitor: Visitor):
        """
        Accepts a visitor.
        """
        visitor.visit(self)


class TrafficAnalysisVisitor(Visitor):
    """
    A visitor that performs complex traffic analysis on city intersections.
    """

    def __init__(self):
        self.traffic_data = {}

    def visit(self, city_intersection: 'CityIntersection'):
        """
        Perform traffic analysis on a city intersection and its children.
        """
        if city_intersection.type == 'FourWayIntersection':
            self.analyze_four_way_intersection(city_intersection)
        elif city_intersection.type == 'TIntersection':
            self.analyze_t_intersection(city_intersection)
        # EDIT: Add a new `elif` block here. Check if `city_intersection.type` is equal to the string 'Roundabout'. If it is, call a new method named `analyze_roundabout`, passing `city_intersection` to it.

        # EDIT: After the if/elif block, you need to make this method visit the connected intersections (the "children").
        # 1. Check if `city_intersection.intersection1` is not None.
        # 2. If it exists, call its `accept` method, passing `self` as the argument. This will make the visitor visit the first child intersection.
        # 3. Check if `city_intersection.intersection2` is not None.
        # 4. If it exists, call its `accept` method, passing `self` as the argument. This will make the visitor visit the second child intersection.

    def analyze_four_way_intersection(self, intersection: 'CityIntersection'):
        """
        Analyze traffic at a four-way intersection.
        """
        traffic_volume = intersection.city.population * intersection.city.traffic
        adjusted_traffic = traffic_volume * 1.2
        self.traffic_data[intersection.city.name] = {
            "type": intersection.type,
            "traffic_volume": adjusted_traffic
        }

    def analyze_t_intersection(self, intersection: 'CityIntersection'):
        """
        Analyze traffic at a T-intersection.
        """
        traffic_volume = intersection.city.population * intersection.city.traffic
        adjusted_traffic = traffic_volume * 1.1
        self.traffic_data[intersection.city.name] = {
            "type": intersection.type,
            "traffic_volume": adjusted_traffic
        }

    # EDIT: Create a new method here called `analyze_roundabout`. It should accept `self` and `intersection` (with type hint 'CityIntersection') as arguments.
    # Inside this method, you will perform the traffic analysis for a roundabout.
    # 1. Calculate the `traffic_volume` by multiplying the intersection's city population (`intersection.city.population`) by its traffic factor (`intersection.city.traffic`).
    # 2. Roundabouts reduce traffic by 30%. Calculate the `adjusted_traffic` by multiplying the `traffic_volume` by 0.7.
    # 3. Add the results to the `self.traffic_data` dictionary. The key should be the city's name (`intersection.city.name`).
    # 4. The value for this key should be another dictionary, containing two key-value pairs:
    #    - a key "type" with the value `intersection.type`
    #    - a key "traffic_volume" with the value of `adjusted_traffic` you calculated.
```
