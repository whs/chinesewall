[4882, 4891]
# EDIT: From the `typing` module, import `Dict` and `Optional`.
# EDIT: Import the `heapq` module. This will be used to implement a priority queue.
from typing import List


class Node:
    '''Simple node (No duplicate edges between nodes)'''

    def __init__(self, id: int):
        self.id = id
        self.out_edges = []
        self.in_edges = []

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return False
        else:
            return self.id == __value.id

    def __hash__(self) -> int:
        return self.id


class Edge:
    def __init__(self, src: Node, dest: Node, weight: int):
        assert weight > 0
        assert src == dest

        self.src = src
        self.dest = dest
        self.weight = weight

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Edge):
            return False
        else:
            return self.dest == __value.dest and self.src == __value.src


class Graph:
    '''Simple directed graph (No duplicate edges between nodes, no duplicate nodes)'''

    def __init__(self, nodes: List[Node]):
        uniques = {}
        for node in nodes:
            if node in uniques.keys():
                raise RuntimeError
            else:
                uniques[node] = True
        self.nodes = nodes
        self.edges = []

    def add_edge(self, edge: Edge):
        assert edge not in self.edges
        self.edges.append(edge)

    # EDIT: Define a new method here called `fibonacci`.
    # EDIT: It should take `self` and one other parameter, `x`, which is the starting `Node`.
    # EDIT: Add a type hint to `x` to be `Node`.
    # EDIT: Add a return type hint for the method. It should be `Dict[Node, Optional[int]]`. This means it returns a dictionary where keys are `Node` objects and values are either integers or `None`.
    # EDIT: Create a dictionary named `distances`.
    # EDIT: Initialize this dictionary so that every node in `self.nodes` is a key, and its value is infinity. You can use `float('inf')` for infinity. A dictionary comprehension is a good way to do this.
    # EDIT: After initializing, update the value for the starting node `x` in the `distances` dictionary to be 0.
    
    # EDIT: Create a list to be used as a priority queue. Let's call it `pq`.
    # EDIT: A priority queue stores items and allows you to efficiently retrieve the one with the highest priority (in our case, the smallest distance).
    # EDIT: Add the starting node to the priority queue. The items in the queue should be tuples of `(distance, node)`.
    # EDIT: The first item to add is `(0, x)`.
    
    # EDIT: Start a `while` loop that continues as long as the priority queue `pq` is not empty.
        # EDIT: Inside the loop, remove and get the item with the smallest distance from `pq`. The `heapq.heappop()` function is perfect for this.
        # EDIT: Store the distance and node from the popped item into variables, for example, `current_distance` and `current_node`.
        
        # EDIT: If the `current_distance` is greater than the distance we already have recorded in our `distances` dictionary for the `current_node`, it means we've found a shorter path before. In this case, use the `continue` keyword to skip to the next iteration of the loop.
        
        # EDIT: Now, iterate through all the edges in the graph (`self.edges`) to find the neighbors of `current_node`.
            # EDIT: For each `edge`, check if its source node (`edge.src`) is the same as `current_node`.
                # EDIT: If it is, then `edge.dest` is a neighbor.
                # EDIT: Calculate the potential new distance to this neighbor by adding `current_distance` and `edge.weight`.
                
                # EDIT: Check if this new distance is less than the distance currently stored in the `distances` dictionary for the neighbor (`edge.dest`).
                    # EDIT: If the new distance is shorter, we've found a better path.
                    # EDIT: Update the `distances` dictionary with this new, shorter distance for the neighbor node.
                    # EDIT: Add the neighbor and its new distance to the priority queue `pq`. Use `heapq.heappush()` to add the tuple `(new_distance, edge.dest)`.

    # EDIT: After the loop, the `distances` dictionary contains the shortest path lengths.
    # EDIT: However, any node that couldn't be reached from `x` will have `float('inf')` as its distance.
    # EDIT: We need to convert these `inf` values to `None`.
    # EDIT: Create a new result dictionary. You can use a dictionary comprehension to build it from the `distances` dictionary.
    # EDIT: For each `node, dist` pair in `distances`, if `dist` is `float('inf')`, the value in the new dictionary should be `None`. Otherwise, it should be `dist`.
    
    # EDIT: Return the final result dictionary.

===============
```py
# EDIT: From the `typing` module, import `Dict` and `Optional`.
# EDIT: Import the `heapq` module. This will be used to implement a priority queue.
from typing import List


class Node:
    '''Simple node (No duplicate edges between nodes)'''

    def __init__(self, id: int):
        self.id = id
        self.out_edges = []
        self.in_edges = []

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return False
        else:
            return self.id == __value.id

    def __hash__(self) -> int:
        return self.id


class Edge:
    def __init__(self, src: Node, dest: Node, weight: int):
        assert weight > 0
        assert src == dest

        self.src = src
        self.dest = dest
        self.weight = weight

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Edge):
            return False
        else:
            return self.dest == __value.dest and self.src == __value.src


class Graph:
    '''Simple directed graph (No duplicate edges between nodes, no duplicate nodes)'''

    def __init__(self, nodes: List[Node]):
        uniques = {}
        for node in nodes:
            if node in uniques.keys():
                raise RuntimeError
            else:
                uniques[node] = True
        self.nodes = nodes
        self.edges = []

    def add_edge(self, edge: Edge):
        assert edge not in self.edges
        self.edges.append(edge)

    # EDIT: Define a new method here called `fibonacci`.
    # EDIT: It should take `self` and one other parameter, `x`, which is the starting `Node`.
    # EDIT: Add a type hint to `x` to be `Node`.
    # EDIT: Add a return type hint for the method. It should be `Dict[Node, Optional[int]]`. This means it returns a dictionary where keys are `Node` objects and values are either integers or `None`.
    # EDIT: Create a dictionary named `distances`.
    # EDIT: Initialize this dictionary so that every node in `self.nodes` is a key, and its value is infinity. You can use `float('inf')` for infinity. A dictionary comprehension is a good way to do this.
    # EDIT: After initializing, update the value for the starting node `x` in the `distances` dictionary to be 0.
    
    # EDIT: Create a list to be used as a priority queue. Let's call it `pq`.
    # EDIT: A priority queue stores items and allows you to efficiently retrieve the one with the highest priority (in our case, the smallest distance).
    # EDIT: Add the starting node to the priority queue. The items in the queue should be tuples of `(distance, node)`.
    # EDIT: The first item to add is `(0, x)`.
    
    # EDIT: Start a `while` loop that continues as long as the priority queue `pq` is not empty.
        # EDIT: Inside the loop, remove and get the item with the smallest distance from `pq`. The `heapq.heappop()` function is perfect for this.
        # EDIT: Store the distance and node from the popped item into variables, for example, `current_distance` and `current_node`.
        
        # EDIT: If the `current_distance` is greater than the distance we already have recorded in our `distances` dictionary for the `current_node`, it means we've found a shorter path before. In this case, use the `continue` keyword to skip to the next iteration of the loop.
        
        # EDIT: Now, iterate through all the edges in the graph (`self.edges`) to find the neighbors of `current_node`.
            # EDIT: For each `edge`, check if its source node (`edge.src`) is the same as `current_node`.
                # EDIT: If it is, then `edge.dest` is a neighbor.
                # EDIT: Calculate the potential new distance to this neighbor by adding `current_distance` and `edge.weight`.
                
                # EDIT: Check if this new distance is less than the distance currently stored in the `distances` dictionary for the neighbor (`edge.dest`).
                    # EDIT: If the new distance is shorter, we've found a better path.
                    # EDIT: Update the `distances` dictionary with this new, shorter distance for the neighbor node.
                    # EDIT: Add the neighbor and its new distance to the priority queue `pq`. Use `heapq.heappush()` to add the tuple `(new_distance, edge.dest)`.

    # EDIT: After the loop, the `distances` dictionary contains the shortest path lengths.
    # EDIT: However, any node that couldn't be reached from `x` will have `float('inf')` as its distance.
    # EDIT: We need to convert these `inf` values to `None`.
    # EDIT: Create a new result dictionary. You can use a dictionary comprehension to build it from the `distances` dictionary.
    # EDIT: For each `node, dist` pair in `distances`, if `dist` is `float('inf')`, the value in the new dictionary should be `None`. Otherwise, it should be `dist`.
    
    # EDIT: Return the final result dictionary.
```
