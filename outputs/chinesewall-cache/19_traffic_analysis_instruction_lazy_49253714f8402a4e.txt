[4694, 4703]
from typing import Optional, Literal
from abc import ABC, abstractmethod


class Visitor(ABC):
    """
    A visitor.
    """

    @abstractmethod
    def visit(self, city_intersection: 'CityIntersection'):
        """
        Visit a city intersection.
        """


class City:
    """
    A city with a name, population, and typical traffic. The traffic is a
    float between 0 and 1 representing the percentage of the population that
    drives at any given time.
    """

    def __init__(self, name: str, population: int, traffic: float):
        self.name = name
        self.population = population
        self.traffic = traffic


IntersectionType = Literal[
    'FourWayIntersection',
    'TIntersection',
    # EDIT: Add 'Roundabout' as a new possible string value for the intersection type.
]


class CityIntersection:
    """
    An intersection between cities. It contains a city, and two intersections.
    """

    def __init__(
        self,
        intersection1: Optional['CityIntersection'],
        intersection2: Optional['CityIntersection'],
        city: City,
        type: IntersectionType,
    ):
        self.intersection1 = intersection1
        self.intersection2 = intersection2
        self.city = city
        self.type = type

    def accept(self, visitor: Visitor):
        """
        Accepts a visitor.
        """
        visitor.visit(self)


class TrafficAnalysisVisitor(Visitor):
    """
    A visitor that performs complex traffic analysis on city intersections.
    """

    def __init__(self):
        self.traffic_data = {}

    def visit(self, city_intersection: 'CityIntersection'):
        """
        Perform traffic analysis on a city intersection and its children.
        """
        if city_intersection.type == 'FourWayIntersection':
            self.analyze_four_way_intersection(city_intersection)
        elif city_intersection.type == 'TIntersection':
            self.analyze_t_intersection(city_intersection)
        # EDIT: Add another `elif` block here to handle the 'Roundabout' type.
        # Check if `city_intersection.type` is equal to 'Roundabout'.
        # If it is, call a new method named `analyze_roundabout_intersection`, passing `city_intersection` as the argument.

        # EDIT: To make the visitor travel to the next intersections, you need to check if there are any connected intersections.
        # 1. Write an `if` statement to check that `city_intersection.intersection1` is not `None`.
        # 2. If it's not `None`, call the `accept` method on `city_intersection.intersection1`, passing `self` (the current visitor) as the argument.
        # EDIT: Now, do the same for the second intersection.
        # 1. Write an `if` statement to check that `city_intersection.intersection2` is not `None`.
        # 2. If it's not `None`, call the `accept` method on `city_intersection.intersection2`, passing `self` as the argument.

    def analyze_four_way_intersection(self, intersection: 'CityIntersection'):
        """
        Analyze traffic at a four-way intersection.
        """
        traffic_volume = intersection.city.population * intersection.city.traffic
        adjusted_traffic = traffic_volume * 1.2
        self.traffic_data[intersection.city.name] = {
            "type": intersection.type,
            "traffic_volume": adjusted_traffic
        }

    def analyze_t_intersection(self, intersection: 'CityIntersection'):
        """
        Analyze traffic at a T-intersection.
        """
        traffic_volume = intersection.city.population * intersection.city.traffic
        adjusted_traffic = traffic_volume * 1.1
        self.traffic_data[intersection.city.name] = {
            "type": intersection.type,
            "traffic_volume": adjusted_traffic
        }

    # EDIT: Create a new method here called `analyze_roundabout_intersection`. It should accept `self` and `intersection` (which is a `CityIntersection`) as parameters.
    # This method will calculate the traffic for a roundabout.
    # Inside the method, follow these steps:
    # 1. Calculate the `traffic_volume` by multiplying the intersection's city population (`intersection.city.population`) by its traffic factor (`intersection.city.traffic`).
    # 2. Roundabouts reduce traffic by 30%. To apply this, calculate `adjusted_traffic` by multiplying `traffic_volume` by 0.7.
    # 3. Just like in the other analysis methods, add an entry to the `self.traffic_data` dictionary.
    #    - The key should be the city's name (`intersection.city.name`).
    #    - The value should be a new dictionary with two key-value pairs:
    #      - "type": `intersection.type`
    #      - "traffic_volume": `adjusted_traffic`

===============
```py
from typing import Optional, Literal
from abc import ABC, abstractmethod


class Visitor(ABC):
    """
    A visitor.
    """

    @abstractmethod
    def visit(self, city_intersection: 'CityIntersection'):
        """
        Visit a city intersection.
        """


class City:
    """
    A city with a name, population, and typical traffic. The traffic is a
    float between 0 and 1 representing the percentage of the population that
    drives at any given time.
    """

    def __init__(self, name: str, population: int, traffic: float):
        self.name = name
        self.population = population
        self.traffic = traffic


IntersectionType = Literal[
    'FourWayIntersection',
    'TIntersection',
    # EDIT: Add 'Roundabout' as a new possible string value for the intersection type.
]


class CityIntersection:
    """
    An intersection between cities. It contains a city, and two intersections.
    """

    def __init__(
        self,
        intersection1: Optional['CityIntersection'],
        intersection2: Optional['CityIntersection'],
        city: City,
        type: IntersectionType,
    ):
        self.intersection1 = intersection1
        self.intersection2 = intersection2
        self.city = city
        self.type = type

    def accept(self, visitor: Visitor):
        """
        Accepts a visitor.
        """
        visitor.visit(self)


class TrafficAnalysisVisitor(Visitor):
    """
    A visitor that performs complex traffic analysis on city intersections.
    """

    def __init__(self):
        self.traffic_data = {}

    def visit(self, city_intersection: 'CityIntersection'):
        """
        Perform traffic analysis on a city intersection and its children.
        """
        if city_intersection.type == 'FourWayIntersection':
            self.analyze_four_way_intersection(city_intersection)
        elif city_intersection.type == 'TIntersection':
            self.analyze_t_intersection(city_intersection)
        # EDIT: Add another `elif` block here to handle the 'Roundabout' type.
        # Check if `city_intersection.type` is equal to 'Roundabout'.
        # If it is, call a new method named `analyze_roundabout_intersection`, passing `city_intersection` as the argument.

        # EDIT: To make the visitor travel to the next intersections, you need to check if there are any connected intersections.
        # 1. Write an `if` statement to check that `city_intersection.intersection1` is not `None`.
        # 2. If it's not `None`, call the `accept` method on `city_intersection.intersection1`, passing `self` (the current visitor) as the argument.
        # EDIT: Now, do the same for the second intersection.
        # 1. Write an `if` statement to check that `city_intersection.intersection2` is not `None`.
        # 2. If it's not `None`, call the `accept` method on `city_intersection.intersection2`, passing `self` as the argument.

    def analyze_four_way_intersection(self, intersection: 'CityIntersection'):
        """
        Analyze traffic at a four-way intersection.
        """
        traffic_volume = intersection.city.population * intersection.city.traffic
        adjusted_traffic = traffic_volume * 1.2
        self.traffic_data[intersection.city.name] = {
            "type": intersection.type,
            "traffic_volume": adjusted_traffic
        }

    def analyze_t_intersection(self, intersection: 'CityIntersection'):
        """
        Analyze traffic at a T-intersection.
        """
        traffic_volume = intersection.city.population * intersection.city.traffic
        adjusted_traffic = traffic_volume * 1.1
        self.traffic_data[intersection.city.name] = {
            "type": intersection.type,
            "traffic_volume": adjusted_traffic
        }

    # EDIT: Create a new method here called `analyze_roundabout_intersection`. It should accept `self` and `intersection` (which is a `CityIntersection`) as parameters.
    # This method will calculate the traffic for a roundabout.
    # Inside the method, follow these steps:
    # 1. Calculate the `traffic_volume` by multiplying the intersection's city population (`intersection.city.population`) by its traffic factor (`intersection.city.traffic`).
    # 2. Roundabouts reduce traffic by 30%. To apply this, calculate `adjusted_traffic` by multiplying `traffic_volume` by 0.7.
    # 3. Just like in the other analysis methods, add an entry to the `self.traffic_data` dictionary.
    #    - The key should be the city's name (`intersection.city.name`).
    #    - The value should be a new dictionary with two key-value pairs:
    #      - "type": `intersection.type`
    #      - "traffic_volume": `adjusted_traffic`
```
